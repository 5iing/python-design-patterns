# Python Design Patterns

디자인 패턴 모음집 각 패턴별로 특징, 장단점, 사용 케이스 정리

## Creational Patterns (생성 패턴)

### Singleton Pattern

- **특징**: 클래스 인스턴스가 하나만 존재하도록 보장
- **장점**: 메모리 절약, 전역 접근점 제공
- **단점**: 전역 상태로 인한 테스트 어려움, 멀티스레드 환경에서 주의 필요
- **사용 케이스**: 로거, 데이터베이스 연결, 설정 관리자

### Factory Pattern

- **특징**: 객체 생성 로직을 별도 클래스로 분리
- **장점**: 객체 생성과 사용 분리, 확장성 좋음
- **단점**: 클래스 수 증가, 복잡도 상승
- **사용 케이스**: 다양한 타입의 객체 생성이 필요한 경우

### Abstract Factory Pattern

- **특징**: 관련된 객체들을 그룹으로 생성하는 팩토리
- **장점**: 일관된 객체 생성, 제품군 교체 용이
- **단점**: 새로운 제품 추가 시 모든 팩토리 수정 필요
- **사용 케이스**: UI 라이브러리, 데이터베이스 드라이버

### Builder Pattern

- **특징**: 복잡한 객체를 단계별로 생성
- **장점**: 가독성 좋음, 선택적 파라미터 처리 용이
- **단점**: 코드량 증가, 간단한 객체에는 과도함
- **사용 케이스**: SQL 쿼리 빌더, HTTP 요청 빌더

### Prototype Pattern

- **특징**: 기존 객체를 복사해서 새 객체 생성
- **장점**: 객체 생성 비용 절약, 동적 객체 생성
- **단점**: 복잡한 객체의 깊은 복사 어려움
- **사용 케이스**: 게임 오브젝트, 문서 템플릿

## Structural Patterns (구조 패턴)

### Adapter Pattern

- **특징**: 호환되지 않는 인터페이스를 연결
- **장점**: 기존 코드 재사용, 인터페이스 통일
- **단점**: 코드 복잡도 증가, 성능 오버헤드
- **사용 케이스**: 레거시 시스템 연동, 서드파티 라이브러리 래핑

### Bridge Pattern

- **특징**: 추상화와 구현을 분리
- **장점**: 독립적 확장 가능, 런타임에 구현 변경
- **단점**: 설계 복잡도 증가, 과도한 추상화 위험
- **사용 케이스**: GUI 프레임워크, 드라이버 시스템

### Composite Pattern

- **특징**: 개별 객체와 복합 객체를 동일하게 처리
- **장점**: 트리 구조 처리 용이, 일관된 인터페이스
- **단점**: 타입 안전성 부족, 과도한 일반화
- **사용 케이스**: 파일 시스템, UI 컴포넌트

### Decorator Pattern

- **특징**: 객체에 동적으로 기능 추가
- **장점**: 상속 없이 기능 확장, 런타임에 동적 변경
- **단점**: 작은 객체들로 인한 복잡도, 디버깅 어려움
- **사용 케이스**: 스트림 처리, 미들웨어, GUI 컴포넌트

### Facade Pattern

- **특징**: 복잡한 서브시스템에 간단한 인터페이스 제공
- **장점**: 사용자 편의성, 서브시스템 결합도 감소
- **단점**: 기능 제한, 서브시스템 변경 시 파사드 수정 필요
- **사용 케이스**: API 래퍼, 복잡한 라이브러리 인터페이스

### Flyweight Pattern

- **특징**: 공통 데이터를 공유해서 메모리 절약
- **장점**: 메모리 사용량 감소, 성능 향상
- **단점**: 코드 복잡도 증가, 상태 관리 어려움
- **사용 케이스**: 텍스트 에디터, 게임 엔진

### Proxy Pattern

- **특징**: 다른 객체에 대한 접근을 제어
- **장점**: 지연 로딩, 접근 제어, 캐싱
- **단점**: 응답 시간 증가, 복잡도 상승
- **사용 케이스**: 가상 프록시, 보안 프록시, 원격 프록시

## Behavioral Patterns (행동 패턴)

### Chain of Responsibility Pattern

- **특징**: 요청을 처리할 수 있는 객체들을 체인으로 연결
- **장점**: 요청자와 처리자 분리, 동적 체인 구성
- **단점**: 처리 보장 어려움, 디버깅 복잡
- **사용 케이스**: 이벤트 처리, 예외 처리, 미들웨어

### Command Pattern

- **특징**: 요청을 객체로 캡슐화
- **장점**: 요청 큐잉, 실행 취소, 로깅 가능
- **단점**: 클래스 수 증가, 메모리 사용량 증가
- **사용 케이스**: GUI 이벤트, 매크로, 트랜잭션

### Iterator Pattern

- **특징**: 컬렉션의 요소들을 순회하는 방법 제공
- **장점**: 컬렉션 구조와 순회 로직 분리, 통일된 인터페이스
- **단점**: 간단한 컬렉션에는 과도함, 성능 오버헤드
- **사용 케이스**: 컬렉션 순회, 데이터베이스 결과 처리

### Mediator Pattern

- **특징**: 객체들 간의 통신을 중재하는 객체 사용
- **장점**: 객체 간 결합도 감소, 통신 로직 중앙화
- **단점**: 중재자 복잡도 증가, 단일 장애점
- **사용 케이스**: 채팅 시스템, GUI 컴포넌트, 이벤트 시스템

### Memento Pattern

- **특징**: 객체의 상태를 저장하고 복원
- **장점**: 상태 저장/복원, 실행 취소 기능
- **단점**: 메모리 사용량 증가, 상태 노출 위험
- **사용 케이스**: 에디터, 게임, 트랜잭션

### Observer Pattern

- **특징**: 객체의 상태 변화를 관찰자들에게 알림
- **장점**: 느슨한 결합, 동적 구독/해제
- **단점**: 메모리 누수 위험, 예측하기 어려운 실행 순서
- **사용 케이스**: 이벤트 시스템, MVC 패턴, 리액티브 프로그래밍

### State Pattern

- **특징**: 객체의 상태에 따라 행동을 변경
- **장점**: 상태별 로직 분리, 상태 전환 명확화
- **단점**: 클래스 수 증가, 상태 전환 복잡도
- **사용 케이스**: 게임 캐릭터, 주문 처리, 자동판매기

### Strategy Pattern

- **특징**: 알고리즘을 클래스로 캡슐화하고 교체 가능하게 만듦
- **장점**: 알고리즘 교체 용이, 조건문 제거
- **단점**: 클래스 수 증가, 클라이언트가 전략 선택 필요
- **사용 케이스**: 정렬 알고리즘, 결제 방식, 압축 알고리즘
